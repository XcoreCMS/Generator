<?php
declare(strict_types=1);

namespace Xcore\Generator\Doctrine\ORM\Entity;

use InvalidArgumentException;
use League\JsonGuard\Validator;
use League\JsonReference\Dereferencer;
use stdClass;
use Xcore\Generator\Doctrine\ORM\Entity\Association\Association;
use Xcore\Generator\Doctrine\ORM\Entity\Association\AssociationType;
use Xcore\Generator\Doctrine\ORM\Entity\Property\GeneratedValueType;
use Xcore\Generator\Doctrine\ORM\Entity\Property\GetterType;
use Xcore\Generator\Doctrine\ORM\Entity\Property\GetterTypeTrait;
use Xcore\Generator\Doctrine\ORM\Entity\Property\NullableTrait;
use Xcore\Generator\Doctrine\ORM\Entity\Property\Property;
use Xcore\Generator\Doctrine\ORM\Entity\Property\SequenceGenerator;
use Xcore\Generator\Doctrine\ORM\Entity\Property\SetterTrait;
use Xcore\Generator\Doctrine\ORM\Entity\Property\Type;
use Xcore\Generator\Doctrine\ORM\Entity\Property\Visibility;
use Xcore\Generator\Doctrine\ORM\Entity\Property\VisibilityTrait;

final class EntityFactory
{
    use VisibilityTrait;
    use AutogeneratedIdsTrait;
    use GetterTypeTrait;
    use SetterTrait;
    use NullableTrait;

    /**
     * @var string
     */
    private $defaultNamespace = 'App\\Entity';

    public function __construct()
    {
        $this->visibility = Visibility::get(Visibility::PUBLIC);
        $this->getter = GetterType::get(GetterType::GET);
        $this->setter = true;
        $this->nullable = false;
    }

    public function getDefaultNamespace(): string
    {
        return $this->defaultNamespace;
    }

    public function setDefaultNamespace($defaultNamespace): void
    {
        $this->defaultNamespace = $defaultNamespace;
    }

    public function createFromJson(string $json): Entity
    {
        $data = json_decode($json);

        $this->validateJson($data);

        $className = $this->getClassName($data);
        $nullable = $data->nullable ?? $this->nullable;
        $visibility = $data->visibility ?? $this->visibility;
        $getter = isset($data->get) ? GetterType::createFromJson($data->get) : $this->getter;
        $setter = $data->set ?? $this->setter;

        $entity = new Entity($className, $nullable, $visibility, $getter, $setter);

        if (isset($data->tableName)) {
            $entity->setTableName($data->tableName);
        }

        if (isset($data->properties)) {
            $properties = $this->createProperties($data->properties, $entity);

            foreach ($properties as $property) {
                if ($property instanceof Property) {
                    $entity->addProperty($property);
                } elseif ($property instanceof Association) {
                    $entity->addAssociation($property);
                }
            }
        }

        return $entity;
    }

    private function validateJson($data): void
    {
        $dereference = Dereferencer::draft4();
        $schema = $dereference->dereference('file://'.__DIR__. '/../../../Resources/schema/entity.json');

        $validator = new Validator($data, $schema);

        if ($validator->fails()) {
            // TODO: remove
            var_dump($validator->errors());

            throw new InvalidArgumentException('Invalid entity JSON');
        }
    }

    private function getClassName(stdClass $data): string
    {
        $namespace = $data->namespace ?? $this->defaultNamespace;

        return "$namespace\\$data->name";
    }

    /**
     * @param stdClass[] $data
     * @param Entity $entity
     * @return Property[]
     */
    private function createProperties(array $data, Entity $entity): array
    {
        $properties = [];

        foreach ($data as $property) {
            if (isset($property->manyToOne)) {
                $properties[] = $this->createAssociation(
                    $property,
                    AssociationType::get(AssociationType::MANY_TO_ONE)
                );
            } elseif (isset($property->oneToOne)) {
                $properties[] = $this->createAssociation(
                    $property,
                    AssociationType::get(AssociationType::ONE_TO_ONE)
                );
            } elseif (isset($property->oneToMany)) {
                $properties[] = $this->createAssociation(
                    $property,
                    AssociationType::get(AssociationType::ONE_TO_MANY)
                );
            } elseif (isset($property->manyToMany)) {
                $properties[] = $this->createAssociation(
                    $property,
                    AssociationType::get(AssociationType::MANY_TO_MANY)
                );
            } else {
                $properties[] = $this->createProperty($property, $entity);
            }
        }

        return $properties;
    }

    private function createProperty(stdClass $data, Entity $entity): Property
    {
        $entity->getVisibility();

        $property = new Property(
            $data->name,
            $data->nullable ?? $entity->isNullable(),
            isset($data->visibility) ? Visibility::get($data->visibility) : $entity->getVisibility(),
            isset($data->get) ? GetterType::createFromJson($data->get) : $entity->getGetter(),
            $data->setter ?? $entity->hasSetter()
        );

        if (isset($data->id)) {
            $property->setId($data->id);
        }

        if (isset($data->generatedValue)) {
            $property->setGeneratedValue(GeneratedValueType::createFromName($data->generatedValue));
        }

        if (isset($data->sequenceGenerator)) {
            $sequenceGenerator = $data->sequenceGenerator;

            $property->setSequenceGenerator(new SequenceGenerator(
                $sequenceGenerator->sequenceName,
                $sequenceGenerator->initialValue ?? null,
                $sequenceGenerator->allocationSize ?? null
            ));
        }

        if (isset($data->type)) {
            $property->setType(Type::get($data->type));
        }

        if (isset($data->columnName)) {
            $property->setColumnName($data->columnName);
        }

        if (isset($data->length)) {
            $property->setLength($data->length);
        }

        return $property;
    }

    private function createAssociation(stdClass $data, AssociationType $type): Association
    {
        $annotationData = $data->{lcfirst($type->getValue())};
        $association = new Association($data->name, $type, $annotationData->targetEntity);

        if (isset($annotationData->mappedBy)) {
            $association->setMappedBy($annotationData->mappedBy);
        }

        if (isset($annotationData->inversedBy)) {
            $association->setInversedBy($annotationData->inversedBy);
        }

        return $association;
    }
}
